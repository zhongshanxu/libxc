/* 
  This file was generated automatically with ./scripts/maple2c.pl.
  Do not edit this file directly as it can be overwritten!!

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

  Maple version     : Maple 2016 (X86 64 LINUX)
  Maple source      : ./maple/gga_vxc/gga_x_lb.mpl
  Type of functional: gga_vxc
*/

#define maple2c_order 2
#define MAPLE2C_FLAGS (XC_FLAGS_I_HAVE_VXC | XC_FLAGS_I_HAVE_FXC)


static inline void
func_unpol(const xc_func_type *p, int order, const double *rho, const double *sigma GGA_OUT_PARAMS_NO_EXC(XC_COMMA double *, ))
{

#ifndef XC_DONT_COMPILE_VXC
  double t1, t4, t5, t6, t10, t11, t12, t13;
  double t15, t17, t18, t19, t20, t21, t23, t24;
  double t25, t26, t28, t29, t30, t33, t34, t38;
  double t39, t40, t43, t45;

#ifndef XC_DONT_COMPILE_FXC
  double t49, t54, t55, t57, t59, t64, t68, t69;
  double t79, t80, t85, t92, t95, t106, t112;
#endif

#endif


  gga_x_lb_params *params;

  assert(p->params != NULL);
  params = (gga_x_lb_params * )(p->params);

  t1 = M_CBRT3;
  t4 = POW_1_3(0.1e1 / M_PI);
  t5 = M_CBRT4;
  t6 = t5 * t5;
  t10 = sqrt(sigma[0]);
  t11 = M_CBRT2;
  t12 = t10 * t11;
  t13 = POW_1_3(rho[0]);
  t15 = 0.1e1 / t13 / rho[0];
  t17 = t12 * t15 < 0.300e3;
  t18 = params->beta * sigma[0];
  t19 = t11 * t11;
  t20 = rho[0] * rho[0];
  t21 = t13 * t13;
  t23 = 0.1e1 / t21 / t20;
  t24 = t19 * t23;
  t25 = params->beta * t10;
  t26 = t11 * t15;
  t28 = params->gamma * t10 * t26;
  t29 = log(t28 + sqrt(t28 * t28 + 0.1e1));
  t30 = t26 * t29;
  t33 = 0.3e1 * t25 * t30 + 0.1e1;
  t34 = 0.1e1 / t33;
  t38 = log(0.2e1 * t28);
  t39 = 0.1e1 / t38;
  t40 = t15 * t39;
  t43 = my_piecewise3(t17, t18 * t24 * t34, t12 * t40 / 0.3e1);
  t45 = (-params->alpha * t1 * t4 * t6 / 0.2e1 - t43) * t19;
  if(vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    vrho[0] = t45 * t13 / 0.2e1;

#ifndef XC_DONT_COMPILE_FXC

  if(order < 2) return;


  t49 = 0.1e1 / t21 / t20 / rho[0];
  t54 = t18 * t19;
  t55 = t33 * t33;
  t57 = t23 / t55;
  t59 = 0.1e1 / t13 / t20;
  t64 = params->gamma * params->gamma;
  t68 = sqrt(t64 * sigma[0] * t24 + 0.1e1);
  t69 = 0.1e1 / t68;
  t79 = t38 * t38;
  t80 = 0.1e1 / t79;
  t85 = my_piecewise3(t17, -0.8e1 / 0.3e1 * t18 * t19 * t49 * t34 - t54 * t57 * (-0.4e1 * t25 * t11 * t59 * t29 - 0.4e1 * t54 * t49 * params->gamma * t69), -0.4e1 / 0.9e1 * t12 * t59 * t39 + 0.4e1 / 0.9e1 * t12 * t59 * t80);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rho2[0] = -t85 * t19 * t13 / 0.2e1 + t45 / t21 / 0.6e1;

  t92 = params->beta * t19;
  t95 = 0.1e1 / t10;
  t106 = t95 * t11;
  t112 = my_piecewise3(t17, t92 * t23 * t34 - t54 * t57 * (0.3e1 / 0.2e1 * t92 * t23 * params->gamma * t69 + 0.3e1 / 0.2e1 * params->beta * t95 * t30), -t106 * t15 * t80 / 0.6e1 + t106 * t40 / 0.6e1);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhosigma[0] = -t112 * t19 * t13 / 0.2e1;

#ifndef XC_DONT_COMPILE_KXC

  if(order < 3) return;


#endif

#endif


}


static inline void
func_pol(const xc_func_type *p, int order, const double *rho, const double *sigma GGA_OUT_PARAMS_NO_EXC(XC_COMMA double *, ))
{

#ifndef XC_DONT_COMPILE_VXC
  double t1, t4, t5, t6, t9, t10, t11, t13;
  double t14, t15, t16, t17, t18, t20, t21, t23;
  double t24, t25, t28, t29, t33, t34, t37, t38;
  double t39, t40, t42, t43, t44, t45, t46, t47;
  double t49, t50, t52, t53, t54, t57, t58, t62;
  double t63, t66, t67;

#ifndef XC_DONT_COMPILE_FXC
  double t70, t74, t76, t78, t82, t86, t87, t95;
  double t97, t98, t102, t109, t113, t115, t117, t124;
  double t125, t133, t135, t136, t140, t145, t147, t157;
  double t162, t164, t166, t176, t181;
#endif

#endif


  gga_x_lb_params *params;

  assert(p->params != NULL);
  params = (gga_x_lb_params * )(p->params);

  t1 = M_CBRT3;
  t4 = POW_1_3(0.1e1 / M_PI);
  t5 = M_CBRT4;
  t6 = t5 * t5;
  t9 = params->alpha * t1 * t4 * t6 / 0.2e1;
  t10 = sqrt(sigma[0]);
  t11 = POW_1_3(rho[0]);
  t13 = 0.1e1 / t11 / rho[0];
  t14 = t10 * t13;
  t15 = t14 < 0.300e3;
  t16 = params->beta * sigma[0];
  t17 = rho[0] * rho[0];
  t18 = t11 * t11;
  t20 = 0.1e1 / t18 / t17;
  t21 = params->beta * t10;
  t23 = params->gamma * t10 * t13;
  t24 = log(t23 + sqrt(t23 * t23 + 0.1e1));
  t25 = t13 * t24;
  t28 = 0.3e1 * t21 * t25 + 0.1e1;
  t29 = 0.1e1 / t28;
  t33 = log(0.2e1 * t23);
  t34 = 0.1e1 / t33;
  t37 = my_piecewise3(t15, t16 * t20 * t29, t14 * t34 / 0.3e1);
  t38 = -t9 - t37;
  if(vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    vrho[0] = t38 * t11;

  t39 = sqrt(sigma[2]);
  t40 = POW_1_3(rho[1]);
  t42 = 0.1e1 / t40 / rho[1];
  t43 = t39 * t42;
  t44 = t43 < 0.300e3;
  t45 = params->beta * sigma[2];
  t46 = rho[1] * rho[1];
  t47 = t40 * t40;
  t49 = 0.1e1 / t47 / t46;
  t50 = params->beta * t39;
  t52 = params->gamma * t39 * t42;
  t53 = log(t52 + sqrt(t52 * t52 + 0.1e1));
  t54 = t42 * t53;
  t57 = 0.3e1 * t50 * t54 + 0.1e1;
  t58 = 0.1e1 / t57;
  t62 = log(0.2e1 * t52);
  t63 = 0.1e1 / t62;
  t66 = my_piecewise3(t44, t45 * t49 * t58, t43 * t63 / 0.3e1);
  t67 = -t9 - t66;
  if(vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    vrho[1] = t67 * t40;

#ifndef XC_DONT_COMPILE_FXC

  if(order < 2) return;


  t70 = 0.1e1 / t18 / t17 / rho[0];
  t74 = t28 * t28;
  t76 = t20 / t74;
  t78 = 0.1e1 / t11 / t17;
  t82 = params->gamma * params->gamma;
  t86 = sqrt(t82 * sigma[0] * t20 + 0.1e1);
  t87 = 0.1e1 / t86;
  t95 = t10 * t78;
  t97 = t33 * t33;
  t98 = 0.1e1 / t97;
  t102 = my_piecewise3(t15, -0.8e1 / 0.3e1 * t16 * t70 * t29 - t16 * t76 * (-0.4e1 * t16 * t70 * params->gamma * t87 - 0.4e1 * t21 * t78 * t24), -0.4e1 / 0.9e1 * t95 * t34 + 0.4e1 / 0.9e1 * t95 * t98);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rho2[0] = -t102 * t11 + t38 / t18 / 0.3e1;

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rho2[1] = 0.0e0;

  t109 = 0.1e1 / t47 / t46 / rho[1];
  t113 = t57 * t57;
  t115 = t49 / t113;
  t117 = 0.1e1 / t40 / t46;
  t124 = sqrt(t82 * sigma[2] * t49 + 0.1e1);
  t125 = 0.1e1 / t124;
  t133 = t39 * t117;
  t135 = t62 * t62;
  t136 = 0.1e1 / t135;
  t140 = my_piecewise3(t44, -0.8e1 / 0.3e1 * t45 * t109 * t58 - t45 * t115 * (-0.4e1 * t45 * t109 * params->gamma * t125 - 0.4e1 * t50 * t117 * t53), 0.4e1 / 0.9e1 * t133 * t136 - 0.4e1 / 0.9e1 * t133 * t63);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rho2[2] = -t140 * t40 + t67 / t47 / 0.3e1;

  t145 = params->beta * t20;
  t147 = 0.1e1 / t10;
  t157 = t147 * t13;
  t162 = my_piecewise3(t15, t145 * t29 - t16 * t76 * (0.3e1 / 0.2e1 * t145 * params->gamma * t87 + 0.3e1 / 0.2e1 * params->beta * t147 * t25), t157 * t34 / 0.6e1 - t157 * t98 / 0.6e1);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhosigma[0] = -t162 * t11;

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhosigma[1] = 0.0e0;

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhosigma[2] = 0.0e0;

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhosigma[3] = 0.0e0;

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhosigma[4] = 0.0e0;

  t164 = params->beta * t49;
  t166 = 0.1e1 / t39;
  t176 = t166 * t42;
  t181 = my_piecewise3(t44, t164 * t58 - t45 * t115 * (0.3e1 / 0.2e1 * t164 * params->gamma * t125 + 0.3e1 / 0.2e1 * params->beta * t166 * t54), -t176 * t136 / 0.6e1 + t176 * t63 / 0.6e1);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhosigma[5] = -t181 * t40;

#ifndef XC_DONT_COMPILE_KXC

  if(order < 3) return;


#endif

#endif


}

