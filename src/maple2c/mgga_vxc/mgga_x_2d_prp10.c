/* 
  This file was generated automatically with ./scripts/maple2c.pl.
  Do not edit this file directly as it can be overwritten!!

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

  Maple version     : Maple 2016 (X86 64 LINUX)
  Maple source      : ./maple/mgga_vxc/mgga_x_2d_prp10.mpl
  Type of functional: mgga_vxc
*/

#define maple2c_order 2
#define MAPLE2C_FLAGS (XC_FLAGS_I_HAVE_VXC | XC_FLAGS_I_HAVE_FXC)


static inline void
func_unpol(const xc_func_type *p, int order, const double *rho, const double *sigma, const double *lapl, const double *tau MGGA_OUT_PARAMS_NO_EXC(XC_COMMA double *, ))
{

#ifndef XC_DONT_COMPILE_VXC
  double t2, t3, t7, t9, t11, t13, t14, t15;
  double t16, t17, t19, t20, t21, t22, t24, t25;
  double t26, t27, t31, t32, t33;

#ifndef XC_DONT_COMPILE_FXC
  double t36, t37, t40, t41, t44, t47, t49, t51;
  double t52, t56, t58, t70, t75, t82, t84, t93;
  double t98;
#endif

#endif



  t2 = rho[0] * rho[0];
  t3 = 0.1e1 / t2;
  t7 = 0.2e1 * tau[0] * t3;
  t9 = 0.1e1 / t2 / rho[0];
  t11 = sigma[0] * t9 / 0.4e1;
  t13 = 0.1e1 / M_PI;
  t14 = (lapl[0] * t3 / 0.2e1 - t7 + t11) * t13;
  t15 = -0.9999999999e0 < t14;
  t16 = my_piecewise3(t15, t14, -0.9999999999e0);
  t17 = exp(-0.1e1);
  t19 = LambertW(t16 * t17);
  t20 = t19 + 0.1e1;
  t21 = t20 / 0.2e1;
  t22 = xc_bessel_I0(t21);
  t24 = t7 - t11;
  t25 = 0.1e-9 < t24;
  t26 = my_piecewise3(t25, t24, 0.1e-9);
  t27 = sqrt(t26);
  t31 = M_SQRT2;
  t32 = (M_PI * t22 - 0.4e1 / 0.3e1 * t13 * t27) * t31;
  t33 = sqrt(rho[0]);
  if(vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    vrho[0] = -t32 * t33 / 0.2e1;

#ifndef XC_DONT_COMPILE_FXC

  if(order < 2) return;


  t36 = xc_bessel_I1(t21);
  t37 = M_PI * t36;
  t40 = 0.4e1 * tau[0] * t9;
  t41 = t2 * t2;
  t44 = 0.3e1 / 0.4e1 * sigma[0] / t41;
  t47 = my_piecewise3(t15, (-lapl[0] * t9 + t40 - t44) * t13, 0);
  t49 = 0.1e1 / t20;
  t51 = 0.1e1 / t16;
  t52 = t19 * t49 * t51;
  t56 = t13 / t27;
  t58 = my_piecewise3(t25, -t40 + t44, 0);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rho2[0] = -(t37 * t47 * t52 / 0.2e1 - 0.2e1 / 0.3e1 * t56 * t58) * t31 * t33 / 0.2e1 - t32 / t33 / 0.4e1;

  t70 = my_piecewise3(t15, t9 * t13 / 0.4e1, 0);
  t75 = my_piecewise3(t25, -t9 / 0.4e1, 0);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhosigma[0] = -(t37 * t70 * t52 / 0.2e1 - 0.2e1 / 0.3e1 * t56 * t75) * t31 * t33 / 0.2e1;

  t82 = t3 * t13;
  t84 = my_piecewise3(t15, t82 / 0.2e1, 0);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_NEEDS_LAPLACIAN) && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rholapl[0] = -t37 * t84 * t19 * t49 * t51 * t31 * t33 / 0.4e1;

  t93 = my_piecewise3(t15, -0.2e1 * t82, 0);
  t98 = my_piecewise3(t25, 0.2e1 * t3, 0);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhotau[0] = -(t37 * t93 * t52 / 0.2e1 - 0.2e1 / 0.3e1 * t56 * t98) * t31 * t33 / 0.2e1;

#ifndef XC_DONT_COMPILE_KXC

  if(order < 3) return;


#endif

#endif


}


static inline void
func_pol(const xc_func_type *p, int order, const double *rho, const double *sigma, const double *lapl, const double *tau MGGA_OUT_PARAMS_NO_EXC(XC_COMMA double *, ))
{

#ifndef XC_DONT_COMPILE_VXC
  double t2, t3, t6, t8, t10, t12, t13, t14;
  double t15, t16, t18, t19, t20, t21, t23, t24;
  double t25, t26, t29, t30, t32, t33, t36, t38;
  double t40, t42, t43, t44, t46, t47, t48, t49;
  double t51, t52, t53, t54, t57, t58;

#ifndef XC_DONT_COMPILE_FXC
  double t60, t61, t65, t66, t69, t72, t75, t76;
  double t77, t81, t83, t91, t92, t96, t97, t100;
  double t103, t106, t107, t108, t112, t114, t122, t124;
  double t130, t132, t140, t145, t152, t157, t162, t166;
  double t171, t175;
#endif

#endif



  t2 = rho[0] * rho[0];
  t3 = 0.1e1 / t2;
  t6 = tau[0] * t3;
  t8 = 0.1e1 / t2 / rho[0];
  t10 = sigma[0] * t8 / 0.8e1;
  t12 = 0.1e1 / M_PI;
  t13 = (lapl[0] * t3 / 0.4e1 - t6 + t10) * t12;
  t14 = -0.9999999999e0 < t13;
  t15 = my_piecewise3(t14, t13, -0.9999999999e0);
  t16 = exp(-0.1e1);
  t18 = LambertW(t15 * t16);
  t19 = t18 + 0.1e1;
  t20 = t19 / 0.2e1;
  t21 = xc_bessel_I0(t20);
  t23 = t6 - t10;
  t24 = 0.1e-9 < t23;
  t25 = my_piecewise3(t24, t23, 0.1e-9);
  t26 = sqrt(t25);
  t29 = M_PI * t21 - 0.4e1 / 0.3e1 * t12 * t26;
  t30 = sqrt(rho[0]);
  if(vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    vrho[0] = -t29 * t30;

  t32 = rho[1] * rho[1];
  t33 = 0.1e1 / t32;
  t36 = tau[1] * t33;
  t38 = 0.1e1 / t32 / rho[1];
  t40 = sigma[2] * t38 / 0.8e1;
  t42 = (lapl[1] * t33 / 0.4e1 - t36 + t40) * t12;
  t43 = -0.9999999999e0 < t42;
  t44 = my_piecewise3(t43, t42, -0.9999999999e0);
  t46 = LambertW(t44 * t16);
  t47 = t46 + 0.1e1;
  t48 = t47 / 0.2e1;
  t49 = xc_bessel_I0(t48);
  t51 = t36 - t40;
  t52 = 0.1e-9 < t51;
  t53 = my_piecewise3(t52, t51, 0.1e-9);
  t54 = sqrt(t53);
  t57 = M_PI * t49 - 0.4e1 / 0.3e1 * t12 * t54;
  t58 = sqrt(rho[1]);
  if(vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    vrho[1] = -t57 * t58;

#ifndef XC_DONT_COMPILE_FXC

  if(order < 2) return;


  t60 = xc_bessel_I1(t20);
  t61 = M_PI * t60;
  t65 = 0.2e1 * tau[0] * t8;
  t66 = t2 * t2;
  t69 = 0.3e1 / 0.8e1 * sigma[0] / t66;
  t72 = my_piecewise3(t14, (-lapl[0] * t8 / 0.2e1 + t65 - t69) * t12, 0);
  t75 = t18 / t19;
  t76 = 0.1e1 / t15;
  t77 = t75 * t76;
  t81 = t12 / t26;
  t83 = my_piecewise3(t24, -t65 + t69, 0);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rho2[0] = -(t61 * t72 * t77 / 0.2e1 - 0.2e1 / 0.3e1 * t81 * t83) * t30 - t29 / t30 / 0.2e1;

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rho2[1] = 0.0e0;

  t91 = xc_bessel_I1(t48);
  t92 = M_PI * t91;
  t96 = 0.2e1 * tau[1] * t38;
  t97 = t32 * t32;
  t100 = 0.3e1 / 0.8e1 * sigma[2] / t97;
  t103 = my_piecewise3(t43, (-lapl[1] * t38 / 0.2e1 + t96 - t100) * t12, 0);
  t106 = t46 / t47;
  t107 = 0.1e1 / t44;
  t108 = t106 * t107;
  t112 = t12 / t54;
  t114 = my_piecewise3(t52, -t96 + t100, 0);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rho2[2] = -(t92 * t103 * t108 / 0.2e1 - 0.2e1 / 0.3e1 * t112 * t114) * t58 - t57 / t58 / 0.2e1;

  t122 = t3 * t12;
  t124 = my_piecewise3(t14, t122 / 0.4e1, 0);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_NEEDS_LAPLACIAN) && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rholapl[0] = -t61 * t124 * t75 * t76 * t30 / 0.2e1;

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_NEEDS_LAPLACIAN) && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rholapl[1] = 0.0e0;

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_NEEDS_LAPLACIAN) && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rholapl[2] = 0.0e0;

  t130 = t33 * t12;
  t132 = my_piecewise3(t43, t130 / 0.4e1, 0);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_NEEDS_LAPLACIAN) && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rholapl[3] = -t92 * t132 * t106 * t107 * t58 / 0.2e1;

  t140 = my_piecewise3(t14, t8 * t12 / 0.8e1, 0);
  t145 = my_piecewise3(t24, -t8 / 0.8e1, 0);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhosigma[0] = -(t61 * t140 * t77 / 0.2e1 - 0.2e1 / 0.3e1 * t81 * t145) * t30;

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhosigma[1] = 0.0e0;

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhosigma[2] = 0.0e0;

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhosigma[3] = 0.0e0;

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhosigma[4] = 0.0e0;

  t152 = my_piecewise3(t43, t38 * t12 / 0.8e1, 0);
  t157 = my_piecewise3(t52, -t38 / 0.8e1, 0);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhosigma[5] = -(t92 * t152 * t108 / 0.2e1 - 0.2e1 / 0.3e1 * t112 * t157) * t58;

  t162 = my_piecewise3(t14, -t122, 0);
  t166 = my_piecewise3(t24, t3, 0);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhotau[0] = -(t61 * t162 * t77 / 0.2e1 - 0.2e1 / 0.3e1 * t81 * t166) * t30;

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhotau[1] = 0.0e0;

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhotau[2] = 0.0e0;

  t171 = my_piecewise3(t43, -t130, 0);
  t175 = my_piecewise3(t52, t33, 0);
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rhotau[3] = -(t92 * t171 * t108 / 0.2e1 - 0.2e1 / 0.3e1 * t112 * t175) * t58;

#ifndef XC_DONT_COMPILE_KXC

  if(order < 3) return;


#endif

#endif


}

